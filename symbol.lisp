;;; -*- Lisp -*-

(in-package "TABLE")

;;; Symbols as tables.  The property list is used as the table.

(defmethod representation ((table symbol))
  (symbol-plist table))

(defmethod (setf representation) (new-representation (table symbol))
  (setf (symbol-plist table) new-representation))

(defmethod table? ((table symbol))
  t)

(defmethod table-p ((table symbol))
  t)

(defmethod table->alist ((table symbol))
  (plist-alist (representation table)))

(defmethod table->node ((table symbol))
  (plist-fold-left (lambda (node key value)
                     (node/add #'less node key value))
                   nil
                   (representation table)))

(defmethod fold-table (function initial-value (table symbol))
  (plist-fold-left function initial-value (representation table)))

(defmethod table/clear ((table symbol))
  (gensym (concatenate 'string (symbol-name table) "-")))

(defmethod table/clear! ((table symbol))
  (setf (symbol-plist table) nil))

(defmethod table/copy ((table symbol))
  (let ((new-table (gensym (concatenate 'string (symbol-name table) "-"))))
    (setf (symbol-plist new-table) (copy-list (representation table)))
    new-table))

(defmethod table/delete ((table symbol) &rest keys)
  (setf (representation table) (apply #'delete-from-plist (representation table) keys))
  table)

(defmethod table/delete-if ((table symbol) predicate)
  (let ((keys-to-delete (plist-fold-left (lambda (keys key value)
                                           (if (funcall predicate key value)
                                               (cons key keys)
                                               keys))
                                         nil
                                         (representation table))))
    (setf (representation table) (apply #'delete-from-plist (representation table) keys-to-delete))))

(defmethod table/delete-if-not ((table symbol) predicate)
  (let ((keys-to-delete (plist-fold-left (lambda (keys key value)
                                           (if (funcall predicate key value)
                                               keys
                                               (cons key keys)))
                                         nil
                                         table)))
    (setf (representation table) (apply #'delete-from-plist (representation table) keys-to-delete))))

(defmethod table/delete-keys ((table symbol) key-list)
  (setf (representation table) (apply #'delete-from-plist (representation table) key-list)))

(defmethod table/difference ((table symbol) (other-table table))
  (let ((result (table/copy table)))
    (table/delete-keys result (table/keys other-table))
    result))

(defmethod table/difference ((table table) (other-table symbol))
  (let ((result (table/copy table)))
    (table/delete-keys result (table/keys other-table))
    result))

(defmethod table/difference ((table symbol) (other-table symbol))
  (let ((result (table/copy table)))
    (table/delete-keys result (table/keys other-table))
    result))

(defmethod table/difference! ((table symbol) (other-table table))
  (table/delete-keys table (table/keys other-table)))

(defmethod table/difference! ((table table) (other-table symbol))
  (table/delete-keys table (table/keys other-table)))

(defmethod table/difference! ((table symbol) (other-table symbol))
  (table/delete-keys table (table/keys other-table)))

(defmethod table/insert ((table symbol) key value)
  (let ((answer (table/copy table)))
    (setf (get answer key) value)
    answer))

(defmethod table/insert! ((table symbol) key value)
  (setf (get table key) value))

(defmethod table/intersection ((table symbol) (other-table table))
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (keys (intersection (table/keys table) (table/keys other-table))))
    (setf (representation answer)
          (plist-fold-right (lambda (key value result)
                              (if (member key keys)
                                  (list* key value result)
                                  result))
                            (representation table)
                            '()))
    answer))

(defmethod table/intersection ((table table) (other-table symbol))
  (fold-left (lambda (answer key)
               (table/insert answer key (table/lookup table key)))
             (table/clear table)
             (intersection (table/keys table) (table/keys other-table))))

(defmethod table/intersection ((table symbol) (other-table symbol))
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (keys (intersection (table/keys table) (table/keys other-table))))
    (setf (representation answer)
          (plist-fold-right (lambda (key value result)
                              (if (member key keys)
                                  (list* key value result)
                                  result))
                            (representation table)
                            '()))
    answer))


(defmethod table/intersection! ((table symbol) (other-table table))
  (let ((keys (intersection (table/keys table) (table/keys other-table))))
    (setf (representation table)
          (plist-fold-right (lambda (key value result)
                              (if (member key keys)
                                  (list* key value result)
                                  result))
                            (representation table)
                            '()))
    table))

(defmethod table/intersection! ((table table) (other-table symbol))
  (let* ((keys (intersection (table/keys table) (table/keys other-table)))
         (to-delete (set-difference (table/keys table) keys)))
    (table/delete-keys table to-delete)))

(defmethod table/intersection! ((table symbol) (other-table symbol))
  (let ((keys (intersection (table/keys table) (table/keys other-table))))
    (setf (representation table)
          (plist-fold-right (lambda (key value result)
                              (if (member key keys)
                                  (list* key value result)
                                  result))
                            (representation table)
                            '()))
    table))

(defmethod table/keys ((table symbol))
  (plist-keys (representation table)))

(defmethod table/lookup ((table symbol) key &optional (default nil))
  (get table key default))

(defmethod table/maximum ((table symbol))
  (plist-maximum (representation table)))

(defmethod table/minimum ((table symbol))
  (plist-minimum (representation table)))

(defmethod table/pop-minimum ((table symbol))
  (symbol-plist-pop-minimum table))

(defmethod table/pop-maximum ((table symbol))
  (symbol-plist-pop-maximum table))

(defmethod table/pop-minimum! ((table symbol))
  (symbol-plist-pop-minimum table))

(defmethod table/pop-maximum! ((table symbol))
   (symbol-plist-pop-maximum table))

(defmethod table/remove ((table symbol) &rest keys)
  (let ((answer (table/copy table)))
    (setf (representation answer)
          (apply #'remove-from-plist (representation table) keys))
    answer))

(defmethod table/remove-keys ((table symbol) keys)
  (let ((answer (table/copy table)))
    (setf (representation answer)
          (apply #'remove-from-plist (representation table) keys))
    answer))

(defmethod table/remove-if ((table symbol) predicate)
  (let ((answer (table/copy table)))
    (setf (representation answer)
          (apply #'remove-from-plist (representation table)
                 (plist-fold-left (lambda (keys key value)
                                    (if (funcall predicate key value)
                                        (cons key keys)
                                        keys))
                                  '()
                                  (representation table))))
    answer))

(defmethod table/remove-if-not ((table symbol) predicate)
  (let ((answer (table/copy table)))
    (setf (representation answer)
          (apply #'remove-from-plist (representation table)
                 (plist-fold-left (lambda (keys key value)
                                    (if (funcall predicate key value)
                                        keys
                                        (cons key keys)))
                                  '()
                                  (representation table))))
    answer))

(defmethod table/size ((table symbol))
  (length (representation table)))

(defmethod table/split-gt ((table symbol) pivot)
  (table/remove-if-not table (lambda (key value) (declare (ignore value)) (greater key pivot))))

(defmethod table/split-lt ((table symbol) pivot)
  (table/remove-if-not table (lambda (key value) (declare (ignore value)) (greater key pivot))))

(defmethod table/subset? ((sub table) (super symbol) &optional (test #'eql))
  (subsetp (table/keys sub) (table/keys super) :test test))

(defmethod table/subset? ((sub symbol) (super table) &optional (test #'eql))
  (subsetp (table/keys sub) (table/keys super :test test)))

(defmethod table/subset? ((sub symbol) (super symbol) &optional (test #'eql))
  (subsetp (table/keys sub) (table/keys super :test test)))

(defmethod table/test ((table symbol)) 'eql)

(defmethod table/union ((table table) (other-table symbol))
  (let ((not-found (cons nil nil)))
    (make-instance (class-of table)
                   :initial-contents
                   (fold-left (lambda (alist key)
                                (let ((probe1 (table/lookup table key not-found))
                                      (probe2 (get other-table key not-found)))
                                  (cond ((eql probe1 not-found) (acons key probe2 alist))
                                        ((eql probe2 not-found) (acons key probe1 alist))
                                        (t (acons key probe1 alist)))))
                              '()
                              (union (table/keys table) (table/keys other-table)))
                   :test (table/test table))))

(defmethod table/union ((table symbol) (other-table table))
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe1 (getf plist key not-found))
                             (probe2 (table/lookup other-table key not-found)))
                         (cond ((eql probe1 not-found) (list* key probe2 plist))
                               ((eql probe2 not-found) (list* key probe1 plist))
                               (t (list* key probe1 plist)))))
                     '()
                      (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union ((table symbol) (other-table symbol))
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe1 (get table key not-found))
                             (probe2 (get other-table key not-found)))
                         (cond ((eql probe1 not-found) (list* key probe2 plist))
                               ((eql probe2 not-found) (list* key probe1 plist))
                               (t (list* key probe1 plist)))))
                      '()
                      (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union! ((table table) (other-table symbol))
  (let ((not-found (cons nil nil))) 
   (plist-fold-left (lambda (table key value)
                       (if (eql (table/lookup table key not-found) not-found)
                           (table/insert! table key value)
                           table))
                     table
                     (representation other-table))))

(defmethod table/union! ((table symbol) (other-table table))
  (let ((not-found (cons nil nil)))
    (setf (representation table)
          (plist-fold-left (lambda (plist key value)
                             (let ((probe (getf plist key not-found)))
                               (if (eql probe not-found)
                                   (list* key value plist)
                                   plist)))
                           '()
                           (representation table)))
    table))

(defmethod table/union! ((table symbol) (other-table symbol))
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe-left (get table key not-found))
                             (probe-right (get other-table key not-found)))
                         (cond ((eq probe-left not-found)  (list* key probe-right plist))
                               ((eq probe-right not-found) (list* key probe-left plist))
                               (t (list* key probe-left plist)))))
                       '()
                       (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union-merge ((table symbol) (other-table table) merge)
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe-left (get table key not-found))
                             (probe-right (table/lookup other-table key not-found)))
                         (cond ((eq probe-left not-found)  (list* key probe-right plist))
                               ((eq probe-right not-found) (list* key probe-left plist))
                               (t (list* key (funcall merge key probe-left probe-right) plist)))))
                     '()
                     (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union-merge ((table table) (other-table symbol) merge)
  (let ((result-keys (union (table/keys table) (table/keys other-table)))
        (not-found (cons nil nil)))
    (make-instance (class-of table)
                   :initial-contents
                   (fold-left (lambda (alist key)
                                (let ((probe-left (table/lookup table key not-found))
                                      (probe-right (get other-table key not-found)))
                                  (cond ((eq probe-left not-found)  (acons key probe-right alist))
                                        ((eq probe-right not-found) (acons key probe-left alist))
                                        (t (acons key (funcall merge key probe-left probe-right) alist)))))
                              '()
                              result-keys)
                   :test (table/test table))))

(defmethod table/union-merge ((table symbol) (other-table symbol) merge)
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe-left (get table key not-found))
                             (probe-right (get other-table key not-found)))
                         (cond ((eq probe-left not-found)  (list* key probe-right plist))
                               ((eq probe-right not-found) (list* key probe-left plist))
                               (t (list* key (funcall merge key probe-left probe-right) plist)))))
                     '()
                     (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union-merge! ((table symbol) (other-table table) merge)
  (let ((answer (gensym (concatenate 'string (symbol-name table) "-")))
        (not-found (cons nil nil)))
    (setf (representation answer)
          (fold-left (lambda (plist key)
                       (let ((probe-left (get table key not-found))
                             (probe-right (table/lookup other-table key not-found)))
                         (cond ((eq probe-left not-found)  (list* key probe-right plist))
                               ((eq probe-right not-found) (list* key probe-left plist))
                               (t (list* key (funcall merge key probe-left probe-right) plist)))))
                     '()
                     (union (table/keys table) (table/keys other-table))))
    answer))

(defmethod table/union-merge! ((table table) (other-table symbol) merge)
  (let ((not-found (cons nil nil)))
    (fold-left (lambda (table key)
                 (let ((probe-left (table/lookup table key not-found))
                       (probe-right (get other-table key not-found)))
                   (cond ((eq probe-left not-found)  (table/insert! table key probe-right))
                         ((eq probe-right not-found) table)
                         (t (table/insert! table key (funcall merge key probe-left probe-right))))))
               table
               (union (table/keys table) (table/keys other-table)))))

(defmethod table/union-merge! ((table symbol) (other-table symbol) merge)
  (let ((not-found (cons nil nil)))
    (setf (representation table)
          (fold-left (lambda (plist key)
                       (let ((probe-left (get table key not-found))
                             (probe-right (get other-table key not-found)))
                         (cond ((eq probe-left not-found)  (list* key probe-right plist))
                               ((eq probe-right not-found) (list* key probe-left plist))
                               (t (list* key (funcall merge key probe-left probe-right) plist)))))
                     '()
                     (union (table/keys table) (table/keys other-table))))
    table))

(defmethod table/values ((table symbol))
  (plist-values (representation table)))

(defmethod table->hash-table ((table symbol) &key (test #'eql))
  (plist-hash-table (representation table) :test test))

(defmethod table->plist ((table symbol))
  (copy-list (representation table)))

(defmethod table->node ((table symbol))
  (plist->node (representation table)))
